{"name":"Actyoung.GitHub.io","tagline":"小虎的博客","body":"# actyoung.github.io\r\n小虎的博客\r\n# HTTP 接口设计指北\r\n\r\n* 文档主要目的是为设计接口时提供建议，使大家不必重复造 HTTP 协议已经完成的轮子\r\n* **只是建议，不是必须遵从的要求**\r\n* 大家有什么问题想法或者建议欢迎 [创建 Issue](https://github.com/bolasblack/http-api-guide/issues/new) 或者 [提交 Pull Request](https://github.com/bolasblack/http-api-guide/compare/)\r\n\r\n## 目录\r\n\r\n* [HTTP 协议](#user-content-http-协议)\r\n* [URL](#user-content-url)\r\n* [空字段](#user-content-空字段)\r\n* [国际化](#user-content-国际化)\r\n* [请求方法](#user-content-请求方法)\r\n* [状态码](#user-content-状态码)\r\n* [错误处理](#user-content-错误处理)\r\n* [身份验证](#user-content-身份验证)\r\n* [超文本驱动和资源发现](#user-content-超文本驱动和资源发现)\r\n* [分页](#user-content-分页)\r\n* [数据缓存](#user-content-数据缓存)\r\n* [并发控制](#user-content-并发控制)\r\n* [跨域](#user-content-跨域)\r\n* [其他资料](#user-content-其他资料)\r\n* [更细节的接口设计指南](#user-content-更细节的接口设计指南)\r\n\r\n## HTTP 协议\r\n\r\n### HTTP/1.1\r\n\r\n2014 年 6 月的时候 IETF 已经正式的废弃了 [RFC 2616](http://tools.ietf.org/html/rfc2616) ，将它拆分为六个单独的协议说明，并重点对原来语义模糊的部分进行了解释：\r\n\r\n* RFC 7230 - HTTP/1.1: [Message Syntax and Routing](http://tools.ietf.org/html/rfc7230) - low-level message parsing and connection management\r\n* RFC 7231 - HTTP/1.1: [Semantics and Content](http://tools.ietf.org/html/rfc7231) - methods, status codes and headers\r\n* RFC 7232 - HTTP/1.1: [Conditional Requests](http://tools.ietf.org/html/rfc7232) - e.g., If-Modified-Since\r\n* RFC 7233 - HTTP/1.1: [Range Requests](http://tools.ietf.org/html/rfc7233) - getting partial content\r\n* RFC 7234 - HTTP/1.1: [Caching](http://tools.ietf.org/html/rfc7234) - browser and intermediary caches\r\n* RFC 7235 - HTTP/1.1: [Authentication](http://tools.ietf.org/html/rfc7235) - a framework for HTTP authentication\r\n\r\n相关资料：\r\n\r\n* [RFC2616 is Dead](https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead) （[中文版](http://www.infoq.com/cn/news/2014/06/http-11-updated)）\r\n\r\n### HTTP/2\r\n\r\nHTTP 协议的 2.0 版本还没有正式发布，但目前已经基本稳定下来了。\r\n\r\n[2.0 版本的设计目标是尽量在使用层面上保持与 1.1 版本的兼容，所以，虽然数据交换的格式发生了变化，但语义基本全部被保留下来了](http://http2.github.io/http2-spec/index.html#rfc.section.8)。\r\n\r\n因此，作为使用者而言，我们并不需要为了支持 2.0 而大幅修改代码。\r\n\r\n* [HTTP/2 latest draft](http://http2.github.io/http2-spec/index.html)\r\n* [HTTP/1.1 和 HTTP/2 数据格式的对比](http://http2.github.io/http2-spec/index.html#rfc.section.8.1.3)\r\n\r\n## URL\r\n\r\nHOST 地址：\r\n\r\n    https://api.example.com\r\n\r\n所有 URI 都需要遵循 [RFC 3986](http://tools.ietf.org/html/rfc3986) 的要求。\r\n\r\n**强烈建议 API 部署 SSL 证书**，这样接口传递的数据的安全性才能都得一定的保障。\r\n\r\n## 空字段\r\n\r\n接口遵循“输入宽容，输出严格”原则，输出的数据结构中空字段的值一律为 `null`\r\n\r\n## 国际化\r\n\r\n### 语言标签\r\n\r\n[RFC 5646](http://tools.ietf.org/html/rfc5646) ([BCP 47](http://tools.ietf.org/html/bcp47)) 规定的语言标签的格式如下：\r\n\r\n```\r\nlanguage-script-region-variant-extension-privateuse\r\n```\r\n\r\n1. `language`：这部分使用的是 ISO 639-1, ISO 639-2, ISO 639-3, ISO 639-5 中定义的语言代码，必填\r\n    * 这个部分由 `primary-extlang` 两个部分构成\r\n    * `primary` 部分使用 ISO 639-1, ISO 639-2, ISO 639-3, ISO 639-5 中定义的语言代码，优先使用 ISO 639-1 中定义的条目，比如汉语 `zh`\r\n    * `extlang` 部分是在某些历史性的兼容性的原因，在需要非常细致地区别 `primary` 语言的时候使用，使用 ISO 639-3 中定义的三个字母的代码，比如普通话 `cmn`\r\n    * 虽然 `language` 可以只写 `extlang` 省略 `primary` 部分，但出于兼容性的考虑，还是**建议**加上 `primary` 部分\r\n2. `script`: 这部分使用的是 [ISO 15924](http://www.unicode.org/iso15924/codelists.html) ([Wikipedia](http://zh.wikipedia.org/wiki/ISO_15924)) 中定义的语言代码，比如简体汉字是 `zh-Hans` ，繁体汉字是 `zh-Hant` 。\r\n3. `region`: 这部分使用的是 [ISO 3166-1][iso3166-1] ([Wikipedia][iso3166-1_wiki]) 中定义的地理区域代码，比如 `zh-Hans-CN` 就是中国大陆使用的简体中文。\r\n4. `variant`: 用来表示 `extlang` 的定义里没有包含的方言，具体的使用方法可以参考 [RFC 5646](http://tools.ietf.org/html/rfc5646#section-2.2.5) 。\r\n5. `extension`: 用来为自己的应用做一些语言上的额外的扩展，具体的使用方法可以参考 [RFC 5646](http://tools.ietf.org/html/rfc5646#section-2.2.6) 。\r\n6. `privateuse`: 用来表示私有协议中约定的一些语言上的区别，具体的使用方法可以参考 [RFC 5646](http://tools.ietf.org/html/rfc5646#section-2.2.7) 。\r\n\r\n其中只有 `language` 部分是必须的，其他部分都是可选的；不过为了便于编写程序，建议设计接口时约定语言标签的结构，比如统一使用 `language-script-region` 的形式（ `zh-Hans-CN`, `zh-Hant-HK` 等等）。\r\n\r\n语言标签是大小写不敏感的，但按照惯例，建议 `script` 部分首字母大写， `region` 部分全部大写，其余部分全部小写。\r\n\r\n**有一点需要注意，任何合法的标签都必须经过 IANA 的认证，已通过认证的标签可以在[这个网页](http://www.iana.org/assignments/language-subtag-registry)查到。此外，网上还有一个非官方的[标签搜索引擎](http://people.w3.org/rishida/utils/subtags/)。**\r\n\r\n相关资料：\r\n\r\n* ISO 639-1 Code List ([Wikipedia](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes))\r\n* [ISO 639-2 Code List](http://www.loc.gov/standards/iso639-2/php/code_list.php) ([Wikipedia](https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes))\r\n* [ISO 639-3 Code List](http://www-01.sil.org/iso639-3/codes.asp?order=639_3&letter=%25)\r\n* [ISO 639-5 Code List](http://www.loc.gov/standards/iso639-5/id.php) ([Wikipedia](https://en.wikipedia.org/wiki/List_of_ISO_639-5_codes))\r\n* [ISO 639-3 Macrolanguage Mappings](http://www-01.sil.org/iso639-3/macrolanguages.asp) ([Wikipedia](https://en.wikipedia.org/wiki/ISO_639_macrolanguage))\r\n* [Relationship between ISO 639-3 and the other parts of ISO 639](http://www-01.sil.org/iso639-3/relationship.asp)\r\n* [网页头部的声明应该是用 lang=\"zh\" 还是 lang=\"zh-cn\"？ - 知乎](http://www.zhihu.com/question/20797118)\r\n* [IETF language tag - Wikipedia](https://en.wikipedia.org/wiki/IETF_language_tag)\r\n* [语种名称代码](http://www.ruanyifeng.com/blog/2008/02/codes_for_language_names.html) ：文中对带有方言（ `extlang` ）部分的标签介绍有误\r\n* [Language tags in HTML and XML](http://www.w3.org/International/articles/language-tags/)\r\n* [Choosing a Language Tag](http://www.w3.org/International/questions/qa-choosing-language-tags)\r\n\r\n### 时区\r\n\r\n客户端请求服务器时，如果对时间有特殊要求（如某段时间每天的统计信息），则可以参考 [IETF 相关草案](http://tools.ietf.org/html/draft-sharhalakis-httptz-05) 增加请求头 `Timezone` 。\r\n\r\n```\r\nTimezone: 2007-06-12T23:48:22+0800\r\n// OR\r\nTimezone: 1977-07-30T12:00:11+0200;;Europe/Athens\r\n```\r\n\r\n时区的名称可以参考 [tz datebase](http://www.iana.org/time-zones)([Wikipedia](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)) 。\r\n\r\n如果客户端请求时没有指定相应的时区，则服务端默认使用 [UTC](http://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6) 时间返回相应数据。\r\n\r\nPS 考虑到存在[夏时制](https://en.wikipedia.org/wiki/Daylight_saving_time)这种东西，所以不推荐客户端在请求时使用 Offset 。\r\n\r\n### 时间格式\r\n\r\n时间格式遵循 [ISO 8601](https://www.iso.org/obp/ui/#iso:std:iso:8601:ed-3:v1:en)([Wikipedia](https://en.wikipedia.org/wiki/ISO_8601)) 建议的格式：\r\n\r\n* 日期 `2014-07-09`\r\n* 时间 `14:31:22+0800`\r\n* 具体时间 `2007-11-06T16:34:41Z`\r\n* 持续时间 `P1Y3M5DT6H7M30S` （表示在一年三个月五天六小时七分三十秒内）\r\n* 时间区间 `2007-03-01T13:00:00Z/2008-05-11T15:30:00Z` 、 `2007-03-01T13:00:00Z/P1Y2M10DT2H30M` 、 `P1Y2M10DT2H30M/2008-05-11T15:30:00Z`\r\n* 重复时间 `R3/2004-05-06T13:00:00+08/P0Y6M5DT3H0M0S` （表示从2004年5月6日北京时间下午1点起，在半年零5天3小时内，重复3次）\r\n\r\n相关资料：\r\n\r\n* [What's the difference between ISO 8601 and RFC 3339 Date Formats?](http://stackoverflow.com/questions/522251/whats-the-difference-between-iso-8601-and-rfc-3339-date-formats)\r\n* [JSON风格指南 - Google 风格指南（中文版）](https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md#%E5%B1%9E%E6%80%A7%E5%80%BC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)\r\n\r\n### 货币名称\r\n\r\n货币名称可以参考 [ISO 4217](javascript:;)([Wikipedia](http://en.wikipedia.org/wiki/ISO_4217)) 中的约定，标准为货币名称规定了三个字母的货币代码，其中的前两个字母是 [ISO 3166-1][iso3166-1]([Wikipedia][iso3166-1_wiki]) 中定义的双字母国家代码，第三个字母通常是货币的首字母。在货币上使用这些代码消除了货币名称（比如 dollar ）或符号（比如 $ ）的歧义。\r\n\r\n相关资料：\r\n\r\n* 《RESTful Web Services Cookbook 中文版》 3.9 节《如何在表述中使用可移植的数据格式》\r\n\r\n## 请求方法\r\n\r\n* [维基百科](http://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#.E8.AF.B7.E6.B1.82.E6.96.B9.E6.B3.95)\r\n* 如果请求头中存在 `X-HTTP-Method-Override` 或参数中存在 `_method`（拥有更高权重），且值为 `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `OPTION`, `HEAD` 之一，则视作相应的请求方式进行处理\r\n* `GET`, `DELETE`, `HEAD` 方法，参数风格为标准的 `GET` 风格的参数，如 `url?a=1&b=2`\r\n* `POST`, `PUT`, `PATCH`, `OPTION` 方法\r\n    * 默认情况下请求实体会被视作标准 json 字符串进行处理，当然，依旧推荐设置头信息的 `Content-Type` 为 `application/json`\r\n    * 在一些特殊接口中（会在文档中说明），可能允许 `Content-Type` 为 `application/x-www-form-urlencoded` 或者 `multipart/form-data` ，此时请求实体会被视作标准 `POST` 风格的参数进行处理\r\n\r\n关于方法语义的说明：\r\n\r\n* `OPTIONS` 用于获取资源支持的所有 HTTP 方法\r\n* `HEAD` 用于只获取请求某个资源返回的头信息\r\n* `GET` 用于从服务器获取某个资源的信息\r\n    * 完成请求后返回状态码 `200 OK`\r\n    * 完成请求后需要返回被请求的资源详细信息\r\n* `POST` 用于创建新资源\r\n    * 创建完成后返回状态码 `201 Created`\r\n    * 完成请求后需要返回被创建的资源详细信息\r\n* `PUT` 用于完整的替换资源或者创建指定身份的资源，比如创建 id 为 123 的某个资源\r\n    * 如果是创建了资源，则返回 `201 Created`\r\n    * 如果是替换了资源，则返回 `200 OK`\r\n    * 完成请求后需要返回被修改的资源详细信息\r\n* `PATCH` 用于局部更新资源\r\n    * 完成请求后返回状态码 `200 OK`\r\n    * 完成请求后需要返回被修改的资源详细信息\r\n* `DELETE` 用于删除某个资源\r\n    * 完成请求后返回状态码 `204 No Content`\r\n\r\n## 状态码\r\n\r\n* [维基百科上的《 HTTP 状态码》词条](http://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)\r\n* [RFC 4918](http://tools.ietf.org/html/rfc4918) - 422 状态码的来源\r\n* [RFC 5789](http://tools.ietf.org/html/rfc5789) - PATCH 方法的定义\r\n* [RFC 6585](http://tools.ietf.org/html/rfc6585) - 新增的四个 HTTP 状态码，[中文版](http://www.oschina.net/news/28660/new-http-status-codes)\r\n* [Do I need to use http redirect code 302 or 307? - Stack Overflow](http://stackoverflow.com/questions/2467664/do-i-need-to-use-http-redirect-code-302-or-307)\r\n* [400 vs 422 response to POST of data](http://stackoverflow.com/questions/16133923/400-vs-422-response-to-post-of-data)\r\n\r\n### 请求成功\r\n\r\n* 200 **OK** : 请求执行成功并返回相应数据，如 `GET` 成功\r\n* 201 **Created** : 对象创建成功并返回相应资源数据，如 `POST` 成功；创建完成后响应头中应该携带头标 `Location` ，指向新建资源的地址\r\n* 204 **No Content** : 请求执行成功，不返回相应资源数据，如 `PATCH` ， `DELETE` 成功\r\n\r\n### 重定向\r\n\r\n**重定向的新地址都需要在响应头 `Location` 中返回**\r\n\r\n* 301 **Moved Permanently** : 被请求的资源已永久移动到新位置\r\n* 302 **Found** : 请求的资源现在临时从不同的 URI 响应请求\r\n* 303 **See Other** : 对应当前请求的响应可以在另一个 URI 上被找到，客户端应该使用 `GET` 方法进行请求\r\n* 307 **Temporary Redirect** : 对应当前请求的响应可以在另一个 URI 上被找到，客户端应该保持原有的请求方法进行请求\r\n\r\n### 客户端出错\r\n\r\n* 400 **Bad Request** : 请求体包含语法错误\r\n* 401 **Unauthorized** : 需要验证用户身份，如果服务器就算是身份验证后也不允许客户访问资源，应该响应 `403 Forbidden`\r\n* 403 **Forbidden** : 服务器拒绝执行\r\n* 404 **Not Found** : 找不到目标资源\r\n* 405 **Method Not Allowed** : 不允许执行目标方法，响应中应该带有 `Allow` 头，内容为对该资源有效的 HTTP 方法\r\n* 406 **Not Acceptable** : 服务器不支持客户端请求的内容格式（比如客户端请求 JSON 格式的数据，但服务器只能提供 XML 格式的数据）\r\n* 409 **Conflict** : 请求操作和资源的当前状态存在冲突\r\n* 410 **Gone** : 被请求的资源已被删除\r\n* 412 **Precondition Failed** : 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。主要使用场景在于实现[并发控制](#user-content-并发控制)\r\n* 413 **Request Entity Too Large** : `POST` 或者 `PUT` 请求的消息实体过大\r\n* 415 **Unsupported Media Type** : 服务器不支持请求中提交的数据的格式\r\n* 422 **Unprocessable Entity** : 请求格式正确，但是由于含有语义错误，无法响应\r\n* 428 **Precondition Required** : 要求先决条件，如果想要请求能成功必须满足一些预设的条件\r\n\r\n### 服务端出错\r\n\r\n* 500 **Internal Server Error** : 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。\r\n* 501 **Not Implemented** : 服务器不支持当前请求所需要的某个功能。\r\n* 502 **Bad Gateway** : 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\r\n* 503 **Service Unavailable** : 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 `Retry-After` 头用以标明这个延迟时间（内容可以为数字，单位为秒；或者是一个 [HTTP 协议指定的时间格式](http://tools.ietf.org/html/rfc2616#section-3.3)）。如果没有给出这个 `Retry-After` 信息，那么客户端应当以处理 500 响应的方式处理它。\r\n\r\n`501` 与 `405` 的区别是：`405` 是表示服务端不允许客户端这么做，`501` 是表示客户端或许可以这么做，但服务端还没有实现这个功能\r\n\r\n## 错误处理\r\n\r\n在调用接口的过程中，可能出现下列几种错误情况：\r\n\r\n* 服务器维护中，`503` 状态码\r\n\r\n    ```http\r\n    HTTP/1.1 503 Service Unavailable\r\n    Retry-After: 3600\r\n    Content-Length: 41\r\n\r\n    {\"message\": \"Service In the maintenance\"}\r\n    ```\r\n\r\n* 发送了无法转化的请求体，`400` 状态码\r\n\r\n    ```http\r\n    HTTP/1.1 400 Bad Request\r\n    Content-Length: 35\r\n\r\n    {\"message\": \"Problems parsing JSON\"}\r\n    ```\r\n\r\n* 服务到期（比如付费的增值服务等）， `403` 状态码\r\n\r\n    ```http\r\n    HTTP/1.1 403 Forbidden\r\n    Content-Length: 29\r\n\r\n    {\"message\": \"Service expired\"}\r\n    ```\r\n\r\n* 因为某些原因不允许访问（比如被 ban ），`403` 状态码\r\n\r\n    ```http\r\n    HTTP/1.1 403 Forbidden\r\n    Content-Length: 29\r\n\r\n    {\"message\": \"Account blocked\"}\r\n    ```\r\n\r\n* 权限不够，`403` 状态码\r\n\r\n    ```http\r\n    HTTP/1.1 403 Forbidden\r\n    Content-Length: 31\r\n\r\n    {\"message\": \"Permission denied\"}\r\n    ```\r\n\r\n* 需要修改的资源不存在， `404` 状态码\r\n\r\n    ```http\r\n    HTTP/1.1 404 Not Found\r\n    Content-Length: 32\r\n\r\n    {\"message\": \"Resource not found\"}\r\n    ```\r\n\r\n* 缺少了必要的头信息，`428` 状态码\r\n\r\n    ```http\r\n    HTTP/1.1 428 Precondition Required\r\n    Content-Length: 35\r\n\r\n    {\"message\": \"Header User-Agent is required\"}\r\n    ```\r\n\r\n* 发送了非法的资源，`422` 状态码\r\n\r\n    ```http\r\n    HTTP/1.1 422 Unprocessable Entity\r\n    Content-Length: 149\r\n\r\n    {\r\n      \"message\": \"Validation Failed\",\r\n      \"errors\": [\r\n        {\r\n          \"resource\": \"Issue\",\r\n          \"field\": \"title\",\r\n          \"code\": \"missing_field\"\r\n        }\r\n      ]\r\n    }\r\n    ```\r\n\r\n所有的 `error` 哈希表都有 `resource`, `field`, `code` 字段，以便于定位错误，`code` 字段则用于表示错误类型：\r\n\r\n* `missing`: 说明某个字段的值代表的资源不存在\r\n* `invalid`: 某个字段的值非法，接口文档中会提供相应的信息\r\n* `missing_field`: 缺失某个必须的字段\r\n* `already_exist`: 发送的资源中的某个字段的值和服务器中已有的某个资源冲突，常见于某些值全局唯一的字段，比如 @ 用的用户名（这个错误我有纠结，因为其实有 409 状态码可以表示，但是在修改某个资源时，很一般显然请求中不止是一种错误，如果是 409 的话，多种错误的场景就不合适了）\r\n\r\n## 身份验证\r\n\r\n部分接口需要通过某种身份验证方式才能请求成功（这些接口**应该**在文档中标注出来），合适的身份验证解决方案目前有两种：\r\n\r\n* [HTTP 基本认证](http://zh.wikipedia.org/wiki/HTTP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81)，**只有在部署了 SSL 证书的情况下才可以使用，否则用户密码会有暴露的风险，当然，最好不要使用**\r\n* [JSON Web Token](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-25) ，支持通过登录接口使用账号密码获取，在请求接口时使用 `Authorization: Bearer #{token}` 头标或者 `token` 参数的值的方式进行验证。\r\n    * [Json Web Tokens: Introduction](http://angular-tips.com/blog/2014/05/json-web-tokens-introduction/)\r\n    * [Json Web Tokens: Examples](http://angular-tips.com/blog/2014/05/json-web-tokens-examples/)\r\n    * [Cookies vs Tokens. Getting auth right with Angular.JS](https://auth0.com/blog/2014/01/07/angularjs-authentication-with-cookies-vs-token/)\r\n* [OAuth 2.0](https://tools.ietf.org/html/rfc6749)\r\n    * [官网](http://oauth.net/2/)\r\n    * [理解OAuth 2.0 - 阮一峰](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html) 以及对[文中 `state` 参数的介绍的修正](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html#comment-323002)\r\n\r\n## 超文本驱动和资源发现\r\n\r\nREST 服务的要求之一，客户端不再需要将某些接口的 URI 硬编码在代码中，唯一需要存储的只是 API 的 HOST 地址，能够非常有效的降低客户端与服务端之间的耦合，服务端对 URI 的任何改动都不会影响到客户端的稳定。\r\n\r\n目前只有几种方案差强人意：\r\n\r\n* [JSON HAL 草案](http://tools.ietf.org/html/draft-kelly-json-hal-06) ，示例可以参考 [JSON HAL 作者自己的介绍](http://stateless.co/hal_specification.html)\r\n* [GitHub API 使用的方案](https://developer.github.com/v3/#hypermedia) ，应该是一种 JSON HAL 的变体\r\n* [JSON API 方案](http://jsonapi.org/)  （这里有 [@迷渡](https://github.com/justjavac) 发起的 [中文版](http://jsonapi.org.cn/) ），另外一种类似 JSON HAL 的方案，不过某些方面（比如甚至也考虑到了 URL ）考虑的比 JSON HAL 更为具体\r\n\r\n目前来看应该是合并 JSON API 和 JSON HAL 两个方案的做法，各取所长，能够得到一个相对理想的方案\r\n\r\n## 分页\r\n\r\n请求某个资源集合时，可以通过指定 `count` 参数来指定每页的资源数量，通过 `page` 参数指定页码，或根据 `last_cursor` 参数指定上一页最后一个资源的标识符。\r\n\r\n如果没有传递 `count` 参数或者 `count` 参数的值为空，则使用默认值 20 ， `count` 参数的最大上限为 100 。\r\n\r\n如何同时传递了 `last_cursor` 和 `page` 参数，则使用 `page` 。\r\n\r\n分页的相关信息会包含在 [Link Header](http://tools.ietf.org/html/rfc5988) 和 `X-Total-Count` 中。\r\n\r\n如果是第一页或者是最后一页时，不会返回 `previous` 和 `next` 的 Link 。\r\n\r\n```http\r\nHTTP/1.1 200 OK\r\nX-Total-Count: 542\r\nLink: <http://api.example.com/#{RESOURCE_URI}?last_cursor=&count=100>; rel=\"first\",\r\n      <http://api.example.com/#{RESOURCE_URI}?last_cursor=200&count=100>; rel=\"last\"\r\n      <http://api.example.com/#{RESOURCE_URI}?last_cursor=90&count=100>; rel=\"previous\",\r\n      <http://api.example.com/#{RESOURCE_URI}?last_cursor=120&count=100>; rel=\"next\",\r\n\r\n[\r\n  ...\r\n]\r\n```\r\n\r\n相关资料：\r\n\r\n* [RFC 5005 第3节 _Paged Feeds_](http://tools.ietf.org/html/rfc5005#section-3)\r\n* [RFC 5988 6.2.2节 _Initial Registry Contents_](http://tools.ietf.org/html/rfc5988#section-6.2.2)\r\n\r\n## 数据缓存\r\n\r\n大部分接口应该在响应头中携带 `Last-Modified` 和 `ETag` 信息，客户端可以在随后请求这些资源的时候，在请求头中使用 `If-Modified-Since` 或者 `If-None-Match` 两个头来确认资源是否经过修改。\r\n\r\n```bash\r\n$ curl -i http://api.example.com/#{RESOURCE_URI}\r\nHTTP/1.1 200 OK\r\nCache-Control: private, max-age=60\r\nETag: \"644b5b0155e6404a9cc4bd9d8b1ae730\"\r\nLast-Modified: Thu, 05 Jul 2012 15:31:30 GMT\r\n\r\n$ curl -i http://api.example.com/#{RESOURCE_URI} -H \"If-Modified-Since: Thu, 05 Jul 2012 15:31:30 GMT\"\r\nHTTP/1.1 304 Not Modified\r\nCache-Control: private, max-age=60\r\nLast-Modified: Thu, 05 Jul 2012 15:31:30 GMT\r\n\r\n$ curl -i http://api.example.com/#{RESOURCE_URI} -H 'If-None-Match: \"644b5b0155e6404a9cc4bd9d8b1ae730\"'\r\nHTTP/1.1 304 Not Modified\r\nCache-Control: private, max-age=60\r\nETag: \"644b5b0155e6404a9cc4bd9d8b1ae730\"\r\nLast-Modified: Thu, 05 Jul 2012 15:31:30 GMT\r\n```\r\n\r\n## 并发控制\r\n\r\n不严谨的实现，或者缺少并发控制的 `PUT` 和 `PATCH` 请求可能导致 “更新丢失”。这个时候可以使用 `Last-Modified` 和/或 `ETag` 头来实现条件请求，支持乐观并发控制。\r\n\r\n下文只考虑使用 `PUT` 和 `PATCH` 方法更新资源的情况。\r\n\r\n* 客户端发起的请求如果没有包含 `If-Unmodified-Since` 或者 `If-Match` 头，那就返回状态码 `403 Forbidden` ，在响应正文中解释为何返回该状态码\r\n* 客户端发起的请求提供的 `If-Unmodified-Since` 或者 `If-Match` 头与服务器记录的实际修改时间和 `ETag` 值不匹配的时候，返回状态码 `412 Precondition Failed`\r\n* 客户端发起的请求提供的条件符合实际值，那就更新资源，响应 `200 OK` 或者 `204 No Content` ，并且包含更新过的 `Last-Modified` 和/或 `ETag` 头，同时包含 `Content-Location` 头，其值为更新后的资源 URI\r\n\r\n相关资料：\r\n\r\n* 《RESTful Web Services Cookbook 中文版》 10.4 节 《如何在服务器端实现条件 PUT 请求》\r\n* [RFC 7232 \"Conditional Requests\"](https://tools.ietf.org/html/rfc7232)\r\n\r\n## 跨域\r\n\r\n### CORS\r\n\r\n接口支持[“跨域资源共享”（Cross Origin Resource Sharing, CORS）](http://www.w3.org/TR/cors)，[这里](http://enable-cors.org/)和[这里](http://code.google.com/p/html5security/wiki/CrossOriginRequestSecurity)和[这份中文资料](http://newhtml.net/using-cors/)有一些指导性的资料。\r\n\r\n简单示例：\r\n\r\n```bash\r\n$ curl -i https://api.example.com -H \"Origin: http://example.com\"\r\nHTTP/1.1 302 Found\r\n```\r\n\r\n```bash\r\n$ curl -i https://api.example.com -H \"Origin: http://example.com\"\r\nHTTP/1.1 302 Found\r\nAccess-Control-Allow-Origin: *\r\nAccess-Control-Expose-Headers: ETag, Link, X-Total-Count\r\nAccess-Control-Allow-Credentials: true\r\n```\r\n\r\n预检请求的响应示例：\r\n\r\n```bash\r\n$ curl -i https://api.example.com -H \"Origin: http://example.com\" -X OPTIONS\r\nHTTP/1.1 302 Found\r\nAccess-Control-Allow-Origin: *\r\nAccess-Control-Allow-Headers: Authorization, Content-Type, If-Match, If-Modified-Since, If-None-Match, If-Unmodified-Since, X-Requested-With\r\nAccess-Control-Allow-Methods: GET, POST, PATCH, PUT, DELETE\r\nAccess-Control-Expose-Headers: ETag, Link, X-Total-Count\r\nAccess-Control-Max-Age: 86400\r\nAccess-Control-Allow-Credentials: true\r\n```\r\n\r\n### JSON-P\r\n\r\n如果在任何 `GET` 请求中带有参数 `callback` ，且值为非空字符串，那么接口将返回如下格式的数据\r\n\r\n```bash\r\n$ curl http://api.example.com/#{RESOURCE_URI}?callback=foo\r\n```\r\n\r\n```javascript\r\nfoo({\r\n  \"meta\": {\r\n    \"status\": 200,\r\n    \"X-Total-Count\": 542,\r\n    \"Link\": [\r\n      {\"href\": \"http://api.example.com/#{RESOURCE_URI}?cursor=0&count=100\", \"rel\": \"first\"},\r\n      {\"href\": \"http://api.example.com/#{RESOURCE_URI}?cursor=90&count=100\", \"rel\": \"prev\"},\r\n      {\"href\": \"http://api.example.com/#{RESOURCE_URI}?cursor=120&count=100\", \"rel\": \"next\"},\r\n      {\"href\": \"http://api.example.com/#{RESOURCE_URI}?cursor=200&count=100\", \"rel\": \"last\"}\r\n    ]\r\n  },\r\n  \"data\": // data\r\n})\r\n```\r\n\r\n## 其他资料\r\n\r\n* [Httpbis Status Pages](https://tools.ietf.org/wg/httpbis/)\r\n* [所有在 IANA 注册的消息头和相关标准的列表](http://www.iana.org/assignments/message-headers/message-headers.xhtml)\r\n\r\n## 更细节的接口设计指南\r\n\r\n这里还有一些其他参考资料：\r\n\r\n* 推荐参考文档 [HTTP API Design Guide](https://github.com/interagent/http-api-design/) 来设计 REST 风格的 API ，只有以下两点我个人并不建议参考：\r\n    * [Use consistent path formats](https://github.com/interagent/http-api-design/#use-consistent-path-formats)\r\n        还是不建议将动作写在 URL 中，像文档中的情况，可以将这个行为抽象成一个事务资源 `POST /runs/:run_id/stop-logs` 或者 `POST /runs/:run_id/stoppers` 来解决\r\n    * [Paginate with Ranges](https://github.com/interagent/http-api-design/#paginate-with-ranges)\r\n        确实是一个巧妙的设计，但似乎并不符合 `Content-Range` 的设计意图，而且有可能和需要使用到 `Content-Range` 的正常场景冲突（虽然几乎不可能），所以不推荐\r\n* [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api)\r\n* [Thoughts on RESTful API Design](http://restful-api-design.readthedocs.org/en/latest/)\r\n* [The RESTful CookBook](http://restcookbook.com/)\r\n\r\n[iso3166-1]: javascript:;\r\n[iso3166-1_wiki]: http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}